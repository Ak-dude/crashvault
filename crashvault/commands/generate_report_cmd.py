"""Generate formatted reports of errors and issues."""
import click, json
from datetime import datetime
from pathlib import Path
from ..core import load_issues, load_events, get_user_config
from rich.console import Console

console = Console()


def _generate_markdown_report(issues, events, filters):
    """Generate a Markdown-formatted report."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    user_config = get_user_config()

    report = f"""# Crashvault Error Report

**Generated:** {timestamp}
**Generated by:** {user_config.get('name', 'Unknown')}
**Team:** {user_config.get('team', 'N/A')}

## Summary

- **Total Issues:** {len(issues)}
- **Total Events:** {len(events)}
- **Filters Applied:** {filters}

## Issues Breakdown

"""

    # Group issues by status
    status_groups = {}
    for issue in issues:
        status = issue.get("status", "unknown")
        if status not in status_groups:
            status_groups[status] = []
        status_groups[status].append(issue)

    for status, issue_list in sorted(status_groups.items()):
        report += f"### {status.upper()} ({len(issue_list)} issues)\n\n"
        for issue in issue_list:
            issue_id = issue.get("id")
            title = issue.get("title", "Untitled")
            created = issue.get("created_at", "N/A")
            event_count = len([e for e in events if e.get("issue_id") == issue_id])
            report += f"- **Issue #{issue_id}:** {title}  \n"
            report += f"  - Created: {created}  \n"
            report += f"  - Events: {event_count}  \n\n"

    # Event level distribution
    report += "## Event Level Distribution\n\n"
    level_counts = {}
    for event in events:
        level = event.get("level", "unknown")
        level_counts[level] = level_counts.get(level, 0) + 1

    for level, count in sorted(level_counts.items(), key=lambda x: -x[1]):
        percentage = (count / len(events) * 100) if events else 0
        report += f"- **{level.upper()}:** {count} ({percentage:.1f}%)  \n"

    # Recent events
    report += "\n## Recent Events (Last 10)\n\n"
    sorted_events = sorted(events, key=lambda e: e.get("timestamp", ""), reverse=True)[:10]
    for event in sorted_events:
        event_id = event.get("event_id", "unknown")
        message = event.get("message", "No message")
        level = event.get("level", "unknown")
        timestamp = event.get("timestamp", "N/A")
        report += f"### {level.upper()} - {message}\n"
        report += f"- **Event ID:** `{event_id}`  \n"
        report += f"- **Timestamp:** {timestamp}  \n"
        report += f"- **Tags:** {', '.join(event.get('tags', []))}  \n\n"

    return report


def _generate_html_report(issues, events, filters):
    """Generate an HTML-formatted report."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    user_config = get_user_config()

    # Count by status
    status_counts = {}
    for issue in issues:
        status = issue.get("status", "unknown")
        status_counts[status] = status_counts.get(status, 0) + 1

    # Level distribution
    level_counts = {}
    for event in events:
        level = event.get("level", "unknown")
        level_counts[level] = level_counts.get(level, 0) + 1

    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crashvault Error Report</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            margin: 0 0 10px 0;
        }}
        .card {{
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        .stats {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }}
        .stat-card {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        .stat-number {{
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
        }}
        .stat-label {{
            color: #666;
            margin-top: 5px;
        }}
        .issue {{
            border-left: 4px solid #667eea;
            padding-left: 15px;
            margin-bottom: 15px;
        }}
        .event {{
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }}
        .level-critical {{ border-left-color: #dc3545; }}
        .level-error {{ border-left-color: #fd7e14; }}
        .level-warning {{ border-left-color: #ffc107; }}
        .level-info {{ border-left-color: #17a2b8; }}
        .level-debug {{ border-left-color: #6c757d; }}
        .badge {{
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            margin-right: 5px;
        }}
        .badge-critical {{ background: #dc3545; color: white; }}
        .badge-error {{ background: #fd7e14; color: white; }}
        .badge-warning {{ background: #ffc107; color: black; }}
        .badge-info {{ background: #17a2b8; color: white; }}
        .badge-debug {{ background: #6c757d; color: white; }}
        .badge-open {{ background: #28a745; color: white; }}
        .badge-resolved {{ background: #6c757d; color: white; }}
        .badge-ignored {{ background: #343a40; color: white; }}
        table {{
            width: 100%;
            border-collapse: collapse;
        }}
        th, td {{
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background-color: #667eea;
            color: white;
        }}
        code {{
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Crashvault Error Report</h1>
        <p><strong>Generated:</strong> {timestamp}</p>
        <p><strong>Generated by:</strong> {user_config.get('name', 'Unknown')} ({user_config.get('email', 'N/A')})</p>
        <p><strong>Team:</strong> {user_config.get('team', 'N/A')}</p>
    </div>

    <div class="stats">
        <div class="stat-card">
            <div class="stat-number">{len(issues)}</div>
            <div class="stat-label">Total Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{len(events)}</div>
            <div class="stat-label">Total Events</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{status_counts.get('open', 0)}</div>
            <div class="stat-label">Open Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{level_counts.get('error', 0) + level_counts.get('critical', 0)}</div>
            <div class="stat-label">Error/Critical Events</div>
        </div>
    </div>

    <div class="card">
        <h2>Issues by Status</h2>
        <table>
            <thead>
                <tr>
                    <th>Issue ID</th>
                    <th>Title</th>
                    <th>Status</th>
                    <th>Created</th>
                    <th>Events</th>
                </tr>
            </thead>
            <tbody>
"""

    for issue in issues:
        issue_id = issue.get("id")
        title = issue.get("title", "Untitled")
        status = issue.get("status", "unknown")
        created = issue.get("created_at", "N/A")
        event_count = len([e for e in events if e.get("issue_id") == issue_id])

        html += f"""
                <tr>
                    <td><code>#{issue_id}</code></td>
                    <td>{title}</td>
                    <td><span class="badge badge-{status}">{status.upper()}</span></td>
                    <td>{created}</td>
                    <td>{event_count}</td>
                </tr>
"""

    html += """
            </tbody>
        </table>
    </div>

    <div class="card">
        <h2>Event Level Distribution</h2>
        <table>
            <thead>
                <tr>
                    <th>Level</th>
                    <th>Count</th>
                    <th>Percentage</th>
                </tr>
            </thead>
            <tbody>
"""

    for level, count in sorted(level_counts.items(), key=lambda x: -x[1]):
        percentage = (count / len(events) * 100) if events else 0
        html += f"""
                <tr>
                    <td><span class="badge badge-{level}">{level.upper()}</span></td>
                    <td>{count}</td>
                    <td>{percentage:.1f}%</td>
                </tr>
"""

    html += """
            </tbody>
        </table>
    </div>

    <div class="card">
        <h2>Recent Events</h2>
"""

    sorted_events = sorted(events, key=lambda e: e.get("timestamp", ""), reverse=True)[:20]
    for event in sorted_events:
        event_id = event.get("event_id", "unknown")
        message = event.get("message", "No message")
        level = event.get("level", "unknown")
        timestamp = event.get("timestamp", "N/A")
        tags = event.get("tags", [])

        html += f"""
        <div class="event level-{level}">
            <h3><span class="badge badge-{level}">{level.upper()}</span> {message}</h3>
            <p><strong>Event ID:</strong> <code>{event_id}</code></p>
            <p><strong>Timestamp:</strong> {timestamp}</p>
            <p><strong>Tags:</strong> {', '.join(tags) if tags else 'None'}</p>
        </div>
"""

    html += """
    </div>
</body>
</html>
"""
    return html


def _generate_json_report(issues, events, filters):
    """Generate a JSON-formatted report."""
    timestamp = datetime.now().isoformat()
    user_config = get_user_config()

    # Calculate statistics
    status_counts = {}
    for issue in issues:
        status = issue.get("status", "unknown")
        status_counts[status] = status_counts.get(status, 0) + 1

    level_counts = {}
    for event in events:
        level = event.get("level", "unknown")
        level_counts[level] = level_counts.get(level, 0) + 1

    report = {
        "generated_at": timestamp,
        "generated_by": user_config.get("name", "Unknown"),
        "team": user_config.get("team", "N/A"),
        "filters": filters,
        "summary": {
            "total_issues": len(issues),
            "total_events": len(events),
            "issues_by_status": status_counts,
            "events_by_level": level_counts
        },
        "issues": issues,
        "events": events
    }

    return json.dumps(report, indent=2)


@click.command(name="generate-report")
@click.option("--format", "output_format", type=click.Choice(["markdown", "html", "json"], case_sensitive=False), default="markdown", help="Report format (default: markdown)")
@click.option("--output", "output_file", type=click.Path(), help="Output file path (default: stdout)")
@click.option("--status", type=click.Choice(["open", "resolved", "ignored"], case_sensitive=False), help="Filter by issue status")
@click.option("--level", type=click.Choice(["debug", "info", "warning", "error", "critical"], case_sensitive=False), help="Filter by event level")
@click.option("--tag", multiple=True, help="Filter by tags (can be specified multiple times)")
def generate_report(output_format, output_file, status, level, tag):
    """Generate formatted reports of errors and issues.

    This command creates comprehensive reports in various formats:
    - Markdown: Easy to read, suitable for documentation
    - HTML: Beautiful web-based report with charts and styling
    - JSON: Structured data for programmatic processing

    Examples:
        crashvault generate-report --format html --output report.html
        crashvault generate-report --format markdown --status open
        crashvault generate-report --format json --output data.json
    """
    # Load issues and events
    issues = load_issues()
    events = load_events()

    # Build filter description
    filters_applied = []
    if status:
        filters_applied.append(f"status={status}")
    if level:
        filters_applied.append(f"level={level}")
    if tag:
        filters_applied.append(f"tags={list(tag)}")
    filter_desc = ", ".join(filters_applied) if filters_applied else "none"

    # Filter issues
    if status:
        issues = [i for i in issues if i.get("status") == status]

    # Filter events
    if status:
        issue_ids = {issue["id"] for issue in issues}
        events = [e for e in events if e.get("issue_id") in issue_ids]

    if level:
        events = [e for e in events if e.get("level") == level]

    if tag:
        tag_set = set(tag)
        events = [e for e in events if tag_set.issubset(set(e.get("tags", [])))]

    if not issues and not events:
        console.print("[yellow]Warning: No data matches the specified filters[/yellow]")

    # Generate report based on format
    if output_format == "markdown":
        report_content = _generate_markdown_report(issues, events, filter_desc)
    elif output_format == "html":
        report_content = _generate_html_report(issues, events, filter_desc)
    elif output_format == "json":
        report_content = _generate_json_report(issues, events, filter_desc)
    else:
        raise click.ClickException(f"Unsupported format: {output_format}")

    # Output report
    if output_file:
        try:
            Path(output_file).write_text(report_content, encoding="utf-8")
            console.print(f"[green]Report generated successfully: {output_file}[/green]")
        except Exception as e:
            raise click.ClickException(f"Error writing report: {str(e)}")
    else:
        click.echo(report_content)
